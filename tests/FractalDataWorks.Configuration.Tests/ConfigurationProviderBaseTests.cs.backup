using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using FluentValidation;
using FluentValidation.Results;
using FractalDataWorks.Configuration.Abstractions;
using FractalDataWorks.Results;
using Microsoft.Extensions.Logging;
using Moq;
using Shouldly;
using Xunit;
using Xunit.v3;
using FractalDataWorks.Configuration;

namespace FractalDataWorks.Configuration.Tests;

/// <summary>
/// Tests for ConfigurationProviderBase class.
/// </summary>
public class ConfigurationProviderBaseTests : IDisposable
{
    private readonly ITestOutputHelper _output;
    private readonly Mock<ILogger> _mockLogger;
    private readonly Mock<IFdwConfigurationSource> _mockSource;
    private readonly TestConfigurationProvider _provider;

    public ConfigurationProviderBaseTests(ITestOutputHelper output)
    {
        _output = output;
        _mockLogger = new Mock<ILogger>();
        _mockSource = new Mock<IFdwConfigurationSource>();
        _provider = new TestConfigurationProvider(_mockLogger.Object, _mockSource.Object);
    }

    [Fact]
    public async Task GetByIdShouldReturnCachedConfiguration()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Test Config 1");
        var configs = new List<TestConfiguration> { config };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // Act
        var result = await _provider.Get(1);

        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();
        result.Value.ShouldNotBeNull();
        result.Value.Id.ShouldBe(1);
        result.Value.Name.ShouldBe("Test Config 1");

        _output.WriteLine($"Retrieved configuration: Id={result.Value.Id}, Name='{result.Value.Name}'");
    }

    [Fact]
    public async Task GetByIdShouldReturnFailureWhenNotFound()
    {
        // Arrange
        var configs = new List<TestConfiguration>();
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // Act
        var result = await _provider.Get(999);

        // Assert
        result.ShouldNotBeNull();
        result.IsFailure.ShouldBeTrue();
        result.Message.ShouldContain("Configuration with ID 999 not found");

        _output.WriteLine($"Expected not found result: {result.Message}");
    }

    [Fact]
    public async Task GetByIdShouldReturnFailureWhenSourceFails()
    {
        // Arrange
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Failure<IEnumerable<TestConfiguration>>("Source error"));

        // Act
        var result = await _provider.Get(1);

        // Assert
        result.ShouldNotBeNull();
        result.IsFailure.ShouldBeTrue();
        result.Message.ShouldBe("Source error");

        _output.WriteLine($"Expected source error result: {result.Message}");
    }

    [Fact]
    public async Task GetByNameShouldReturnConfiguration()
    {
        // Arrange
        var configs = new List<TestConfiguration>
        {
            CreateTestConfiguration(1, "Config One"),
            CreateTestConfiguration(2, "Config Two")
        };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // Act
        var result = await _provider.Get("Config Two");

        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();
        result.Value.ShouldNotBeNull();
        result.Value.Id.ShouldBe(2);
        result.Value.Name.ShouldBe("Config Two");

        _output.WriteLine($"Retrieved configuration by name: Id={result.Value.Id}, Name='{result.Value.Name}'");
    }

    [Theory]
    [InlineData(null)]
    [InlineData("")]
    [InlineData("   ")]
    public async Task GetByNameShouldReturnFailureForInvalidName(string? name)
    {
        // Act
        var result = await _provider.Get(name!);

        // Assert
        result.ShouldNotBeNull();
        result.IsFailure.ShouldBeTrue();
        result.Message.ShouldBe("Invalid configuration name");

        _output.WriteLine($"Expected invalid name result for '{name}': {result.Message}");
    }

    [Fact]
    public async Task GetByNameShouldBeCaseInsensitive()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Test Config");
        var configs = new List<TestConfiguration> { config };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // Act
        var result = await _provider.Get("TEST CONFIG");

        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();
        result.Value.ShouldNotBeNull();
        result.Value.Name.ShouldBe("Test Config");

        _output.WriteLine($"Case insensitive match found: '{result.Value.Name}'");
    }

    [Fact]
    public async Task GetAllShouldReturnAllConfigurations()
    {
        // Arrange
        var configs = new List<TestConfiguration>
        {
            CreateTestConfiguration(1, "Config 1"),
            CreateTestConfiguration(2, "Config 2"),
            CreateTestConfiguration(3, "Config 3")
        };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // Act
        var result = await _provider.GetAll();

        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();
        result.Value.ShouldNotBeNull();
        result.Value.Count().ShouldBe(3);

        _output.WriteLine($"Retrieved {result.Value.Count()} configurations");
        foreach (var config in result.Value)
        {
            _output.WriteLine($"  - {config.Name} (ID: {config.Id})");
        }
    }

    [Fact]
    public async Task GetEnabledShouldReturnOnlyEnabledConfigurations()
    {
        // Arrange
        var configs = new List<TestConfiguration>
        {
            CreateTestConfiguration(1, "Enabled 1", true),
            CreateTestConfiguration(2, "Disabled", false),
            CreateTestConfiguration(3, "Enabled 2", true)
        };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // Act
        var result = await _provider.GetEnabled();

        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();
        result.Value.ShouldNotBeNull();
        result.Value.Count().ShouldBe(2);
        result.Value.ShouldAllBe(c => c.IsEnabled);

        _output.WriteLine($"Retrieved {result.Value.Count()} enabled configurations");
        foreach (var config in result.Value)
        {
            _output.WriteLine($"  - {config.Name} (Enabled: {config.IsEnabled})");
        }
    }

    [Fact]
    public async Task SaveShouldReturnFailureForNullConfiguration()
    {
        // Act
        var result = await _provider.Save(null!);

        // Assert
        result.ShouldNotBeNull();
        result.IsFailure.ShouldBeTrue();
        result.Message.ShouldBe("Configuration cannot be null");

        _output.WriteLine($"Expected null configuration error: {result.Message}");
    }

    [Fact]
    public async Task SaveShouldReturnFailureForInvalidConfiguration()
    {
        // Arrange
        var provider = new TestConfigurationWithValidationProvider(_mockLogger.Object, _mockSource.Object);
        var invalidConfig = new TestConfigurationWithValidation
        {
            Id = 1,
            Name = "", // Invalid - empty name
            IsEnabled = true
        };

        // Act
        var result = await provider.Save(invalidConfig);

        // Assert
        result.ShouldNotBeNull();
        result.IsFailure.ShouldBeTrue();
        result.Message.ShouldContain("Configuration validation failed");

        _output.WriteLine($"Expected validation error: {result.Message}");
    }

    [Fact]
    public async Task SaveShouldSucceedForValidConfiguration()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Valid Config");
        
        _mockSource.Setup(s => s.Save(config))
            .ReturnsAsync(FdwResult<TestConfiguration>.Success(config));

        // Act
        var result = await _provider.Save(config);

        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();
        result.Value.ShouldBe(config);

        _output.WriteLine($"Successfully saved configuration: {config.Name}");
    }

    [Fact]
    public async Task SaveShouldSetModifiedAtForExistingConfiguration()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Existing Config");
        var beforeSave = DateTime.UtcNow;
        
        _mockSource.Setup(s => s.Save(It.IsAny<TestConfiguration>()))
            .ReturnsAsync((TestConfiguration c) => FdwResult<TestConfiguration>.Success(c));

        // Act
        var result = await _provider.Save(config);

        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();
        result.Value.ModifiedAt.ShouldNotBeNull();
        result.Value.ModifiedAt.Value.ShouldBeGreaterThanOrEqualTo(beforeSave);

        _output.WriteLine($"Configuration modified at: {result.Value.ModifiedAt}");
    }

    [Theory]
    [InlineData(0)]
    [InlineData(-1)]
    [InlineData(-999)]
    public async Task DeleteShouldReturnFailureForInvalidId(int invalidId)
    {
        // Act
        var result = await _provider.Delete(invalidId);

        // Assert
        result.ShouldNotBeNull();
        result.IsFailure.ShouldBeTrue();
        result.Message.ShouldBe("Invalid configuration ID");

        _output.WriteLine($"Expected invalid ID error for {invalidId}: {result.Message}");
    }

    [Fact]
    public async Task DeleteShouldSucceedForValidId()
    {
        // Arrange
        _mockSource.Setup(s => s.Delete<TestConfiguration>(1))
            .ReturnsAsync(FdwResult<NonResult>.Success(NonResult.Value));

        // Act
        var result = await _provider.Delete(1);

        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();

        _output.WriteLine("Successfully deleted configuration");
    }

    [Fact]
    public async Task ReloadShouldClearCacheAndSucceed()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Cached Config");
        var configs = new List<TestConfiguration> { config };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // First load to populate cache
        await _provider.Get(1);

        // Act
        var reloadResult = await _provider.Reload();

        // Assert
        reloadResult.ShouldNotBeNull();
        reloadResult.IsSuccess.ShouldBeTrue();

        _output.WriteLine("Successfully reloaded configuration cache");
    }

    [Fact]
    public void DisposeShouldUnsubscribeFromSourceChanges()
    {
        // Arrange
        _mockSource.SetupAdd(s => s.Changed += It.IsAny<EventHandler<ConfigurationSourceChangedEventArgs>>());
        _mockSource.SetupRemove(s => s.Changed -= It.IsAny<EventHandler<ConfigurationSourceChangedEventArgs>>());

        // Act
        _provider.Dispose();

        // Assert
        _mockSource.VerifyRemove(s => s.Changed -= It.IsAny<EventHandler<ConfigurationSourceChangedEventArgs>>(), Times.Once);

        _output.WriteLine("Verified event unsubscription on dispose");
    }

    [Fact]
    public async Task OnSourceChangedShouldIgnoreWrongConfigurationType()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Original Config");
        var configs = new List<TestConfiguration> { config };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // Load configuration into cache first
        await _provider.Get(1);
        
        var wrongTypeEventArgs = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Updated,
            typeof(ConfigurationBase<TestConfiguration>), // Wrong type
            1);

        // Act - Trigger the event with wrong type
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, wrongTypeEventArgs);
        
        // Allow some time for async operation
        await Task.Delay(100);

        // Assert - Cache should be unchanged, configuration should still be accessible
        var result = await _provider.Get(1);
        result.IsSuccess.ShouldBeTrue();
        result.Value.Name.ShouldBe("Original Config");
        
        _output.WriteLine("OnSourceChanged correctly ignored wrong configuration type");
    }

    [Fact] 
    public async Task OnSourceChangedShouldHandleDeletedWithConfigurationId()
    {
        // Arrange
        var config1 = CreateTestConfiguration(1, "Config 1");
        var config2 = CreateTestConfiguration(2, "Config 2");
        var configs = new List<TestConfiguration> { config1, config2 };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // First load both configurations into cache
        await _provider.Get(1);
        await _provider.Get(2);
        
        // Update mock to exclude config 1 (simulating deletion)
        var updatedConfigs = new List<TestConfiguration> { config2 };
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(updatedConfigs));
        
        var deletedEventArgs = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Deleted,
            typeof(TestConfiguration),
            1);

        // Act
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, deletedEventArgs);
        
        // Allow time for async operation
        await Task.Delay(100);

        // Assert - Config 1 should be removed from cache and not found when reloaded
        var result1 = await _provider.Get(1);
        var result2 = await _provider.Get(2);
        
        result1.IsFailure.ShouldBeTrue(); // Should not be found after cache removal
        result1.Message.ShouldContain("Configuration with ID 1 not found");
        result2.IsSuccess.ShouldBeTrue(); // Should remain accessible
        
        _output.WriteLine("OnSourceChanged correctly handled Deleted event with specific configuration ID");
    }

    [Fact]
    public async Task OnSourceChangedShouldHandleDeletedWithoutConfigurationId()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Test Config");
        var configs = new List<TestConfiguration> { config };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));
            
        await _provider.Get(1); // Load into cache
        
        var deletedEventArgs = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Deleted,
            typeof(TestConfiguration),
            null); // No specific ID

        // Act
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, deletedEventArgs);
        
        // Allow time for async operation
        await Task.Delay(100);

        // Assert - Should still work as cache item remains (no specific ID to remove)
        var result = await _provider.Get(1);
        result.IsSuccess.ShouldBeTrue();
        
        _output.WriteLine("OnSourceChanged correctly handled Deleted event without configuration ID");
    }

    [Fact]
    public async Task OnSourceChangedShouldHandleReloaded()
    {
        // Arrange
        var config1 = CreateTestConfiguration(1, "Config 1");
        var config2 = CreateTestConfiguration(2, "Config 2");
        var configs = new List<TestConfiguration> { config1, config2 };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        // Load both into cache
        await _provider.Get(1);
        await _provider.Get(2);
        
        // Update the configurations in the mock
        config1.Name = "Updated Config 1";
        config2.Name = "Updated Config 2";
        
        var reloadedEventArgs = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Reloaded,
            typeof(TestConfiguration),
            null);

        // Act
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, reloadedEventArgs);
        
        // Allow time for async operation
        await Task.Delay(100);

        // Assert - Both configurations should be reloaded from source
        var result1 = await _provider.Get(1);
        var result2 = await _provider.Get(2);
        
        result1.IsSuccess.ShouldBeTrue();
        result1.Value.Name.ShouldBe("Updated Config 1");
        result2.IsSuccess.ShouldBeTrue();
        result2.Value.Name.ShouldBe("Updated Config 2");
        
        _output.WriteLine("OnSourceChanged correctly handled Reloaded event, clearing entire cache");
    }

    [Fact]
    public async Task OnSourceChangedShouldHandleAddedWithConfigurationId()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Original Config");
        var configs = new List<TestConfiguration> { config };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));
            
        await _provider.Get(1); // Load into cache
        
        // Update the source configuration
        config.Name = "Updated Config";
        
        var addedEventArgs = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Added,
            typeof(TestConfiguration),
            1);

        // Act
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, addedEventArgs);
        
        // Allow time for async operation
        await Task.Delay(100);

        // Assert - Configuration should be reloaded from source on next access
        var result = await _provider.Get(1);
        result.IsSuccess.ShouldBeTrue();
        result.Value.Name.ShouldBe("Updated Config");
        
        _output.WriteLine("OnSourceChanged correctly handled Added event with specific configuration ID");
    }

    [Fact]
    public async Task OnSourceChangedShouldHandleUpdatedWithConfigurationId()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Original Config");
        var configs = new List<TestConfiguration> { config };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));
            
        await _provider.Get(1); // Load into cache
        
        // Update the source configuration
        config.Name = "Updated Config";
        
        var updatedEventArgs = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Updated,
            typeof(TestConfiguration),
            1);

        // Act
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, updatedEventArgs);
        
        // Allow time for async operation
        await Task.Delay(100);

        // Assert - Configuration should be reloaded from source on next access
        var result = await _provider.Get(1);
        result.IsSuccess.ShouldBeTrue();
        result.Value.Name.ShouldBe("Updated Config");
        
        _output.WriteLine("OnSourceChanged correctly handled Updated event with specific configuration ID");
    }

    [Fact]
    public async Task OnSourceChangedShouldHandleAddedWithoutConfigurationId()
    {
        // Arrange
        var config = CreateTestConfiguration(1, "Test Config");
        var configs = new List<TestConfiguration> { config };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));
            
        await _provider.Get(1); // Load into cache
        
        var addedEventArgs = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Added,
            typeof(TestConfiguration),
            null); // No specific ID

        // Act
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, addedEventArgs);
        
        // Allow time for async operation
        await Task.Delay(100);

        // Assert - Configuration should remain accessible
        var result = await _provider.Get(1);
        result.IsSuccess.ShouldBeTrue();
        
        _output.WriteLine("OnSourceChanged correctly handled Added event without configuration ID");
    }

    [Fact]
    public async Task OnSourceChangedShouldHandleUpdatedWithoutConfigurationId()
    {
        // Arrange  
        var config = CreateTestConfiguration(1, "Test Config");
        var configs = new List<TestConfiguration> { config };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));
            
        await _provider.Get(1); // Load into cache
        
        var updatedEventArgs = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Updated,
            typeof(TestConfiguration),
            null); // No specific ID

        // Act
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, updatedEventArgs);
        
        // Allow time for async operation
        await Task.Delay(100);

        // Assert - Configuration should remain accessible
        var result = await _provider.Get(1);
        result.IsSuccess.ShouldBeTrue();
        
        _output.WriteLine("OnSourceChanged correctly handled Updated event without configuration ID");
    }

    [Fact]
    public async Task OnSourceChangedShouldHandleConcurrentEvents()
    {
        // Arrange
        var config1 = CreateTestConfiguration(1, "Config 1");
        var config2 = CreateTestConfiguration(2, "Config 2");
        var configs = new List<TestConfiguration> { config1, config2 };
        
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(configs));

        await _provider.Get(1);
        await _provider.Get(2);
        
        // Update config1 in source
        config1.Name = "Updated Config 1";
        
        // Set up mock to exclude config2 for deletion test
        var updatedConfigs = new List<TestConfiguration> { config1 };
        _mockSource.Setup(s => s.Load<TestConfiguration>())
            .ReturnsAsync(FdwResult<IEnumerable<TestConfiguration>>.Success(updatedConfigs));
        
        var event1 = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Updated,
            typeof(TestConfiguration),
            1);
            
        var event2 = new ConfigurationSourceChangedEventArgs(
            ConfigurationChangeType.Deleted,
            typeof(TestConfiguration),
            2);

        // Act - Fire multiple concurrent events
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, event1);
        _mockSource.Raise(s => s.Changed += null, _mockSource.Object, event2);
        
        // Allow time for async operations
        await Task.Delay(200);

        // Assert - Both events should be processed correctly
        var result1 = await _provider.Get(1);
        var result2 = await _provider.Get(2);
        
        result1.IsSuccess.ShouldBeTrue(); // Updated, should reload
        result1.Value.Name.ShouldBe("Updated Config 1");
        result2.IsFailure.ShouldBeTrue(); // Deleted, should be removed from cache
        
        _output.WriteLine("OnSourceChanged correctly handled concurrent events");
    }

    [Fact]
    public void DisposeShouldHandleNonManagedDisposal()
    {
        // Arrange
        var provider = new TestConfigurationProviderForDispose(_mockLogger.Object, _mockSource.Object);

        // Act - Call protected Dispose(false) method via reflection to test unmanaged cleanup path
        var disposeMethod = typeof(ConfigurationProviderBase<TestConfiguration>)
            .GetMethod("Dispose", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance, 
                       new[] { typeof(bool) });
        
        // Test unmanaged disposal path
        disposeMethod?.Invoke(provider, new object[] { false });

        // Assert - No exception should be thrown
        _output.WriteLine("Non-managed disposal completed without errors");
        
        // Now test managed disposal to ensure it still works
        provider.Dispose();
        _output.WriteLine("Managed disposal also completed successfully");
    }

    [Fact]
    public void DisposeShouldHandleManagedDisposalProperly()
    {
        // Arrange - Use a provider that we can verify disposal behavior
        var provider = new TestConfigurationProviderForDispose(_mockLogger.Object, _mockSource.Object);

        // Act - Call managed disposal
        provider.Dispose();

        // Assert - Should have unsubscribed from events
        // Note: We can't easily verify _cacheLock disposal as it's private, but we can verify no exceptions occur
        _output.WriteLine("Managed disposal completed - event unsubscription should have occurred");
        
        // Calling dispose again should not cause issues
        provider.Dispose();
        _output.WriteLine("Multiple dispose calls handled gracefully");
    }

    public void Dispose()
    {
        _provider?.Dispose();
    }

    private static TestConfiguration CreateTestConfiguration(int id, string name, bool isEnabled = true)
    {
        return new TestConfiguration
        {
            Id = id,
            Name = name,
            IsEnabled = isEnabled
        };
    }

    // Test implementation of ConfigurationProviderBase
    public class TestConfigurationProvider : ConfigurationProviderBase<TestConfiguration>
    {
        public List<TestConfiguration> TestConfigurations { get; } = new();

        public TestConfigurationProvider(ILogger logger, IFdwConfigurationSource source)
            : base(logger, source)
        {
        }
    }

    // Test implementation for validation testing
    public class TestConfigurationWithValidationProvider : ConfigurationProviderBase<TestConfigurationWithValidation>
    {
        public TestConfigurationWithValidationProvider(ILogger logger, IFdwConfigurationSource source)
            : base(logger, source)
        {
        }
    }

    // Test implementation for dispose testing
    public class TestConfigurationProviderForDispose : ConfigurationProviderBase<TestConfiguration>
    {
        public TestConfigurationProviderForDispose(ILogger logger, IFdwConfigurationSource source)
            : base(logger, source)
        {
        }
    }

    // Test configuration class
    public class TestConfiguration : ConfigurationBase<TestConfiguration>
    {
        public override string SectionName => "TestSection";
    }

    // Test configuration with validation
    public class TestConfigurationWithValidation : ConfigurationBase<TestConfigurationWithValidation>
    {
        public override string SectionName => "TestSectionWithValidation";

        protected override IValidator<TestConfigurationWithValidation>? GetValidator()
        {
            return new TestValidator();
        }

        private class TestValidator : AbstractValidator<TestConfigurationWithValidation>
        {
            public TestValidator()
            {
                RuleFor(x => x.Name)
                    .NotEmpty()
                    .WithMessage("Name is required");
            }
        }
    }
}